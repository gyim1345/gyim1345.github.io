{"expireTime":9007200837854416000,"key":"transformer-remark-markdown-html-20e14afccd2bfdfff7d1a4493dbb49d5-gatsby-remark-relative-imagesgatsby-remark-katexgatsby-remark-imagesgatsby-remark-responsive-iframegatsby-remark-autolink-headersgatsby-remark-prismjsgatsby-remark-copy-linked-filesgatsby-remark-smartypantsgatsby-remark-external-links-","val":"<h1 id=\"ch6\" style=\"position:relative;\"><a href=\"#ch6\" aria-label=\"ch6 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>CH6</h1>\n<p>HTTP란 hypertext 전송용 프로토콜이지만 hypertext인 HTML과 XML뿐만 아니라 이미지, 동영상, JavaScript 프로그램, 등 모든 컴퓨터 데이터를 전송 할 수 있다.</p>\n<p>HTTP는 Rest 기반인 Uniform 인터페이스, stateless 서버, 캐시 등을 구현 하는 Web 기반이 되는 프로토콜이다.</p>\n<p>HTTP는 TCP/IP(Transmission Control Protocol/Internet Protocol) 기반으로 한다. 이것은 인터넷이 따르는 네트워크 프로토콜이다.</p>\n<p>TCP/IP는 계층형 프로토콜 구조를 가지고 있다</p>\n<p>네트워크 인터페이스 계층 - 물리적인 케이블 등.<br>\n인터넷 계층 - 네트워크에서 데이터를 주고받는 부분. 패킷 단위로 주고받아서 통신함.<br>\n트랜스포트 계층 - 데이터 무결성 확인 및 커넥션 보조. 소켓을 이용해서 클라이언트와 서버 연결함<br>\n애플리케이션 계층 - 인터넷  애플리케이(메일, http 등) 구현  </p>\n<table>\n<thead>\n<tr>\n<th>TCP/IP</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>애플리케이션 계층 (HTTP, NTP, SSH, SMTP, DNS)</td>\n</tr>\n<tr>\n<td>트랜스포트 계층(UDP, TCP)</td>\n</tr>\n<tr>\n<td>인터넷 계층 (IP)</td>\n</tr>\n<tr>\n<td>네트워크 인터페이스 계층 (이더넷)</td>\n</tr>\n</tbody>\n</table>\n<p>웹은 클라이언트/서버 아키텍처를 가지고 있다. client에서 request를 보내고 server에서 respond를 보내는 구조다. 이런 구조를 요청/응답형(request-response style)이라고 정의한다.</p>\n<p>http는 클라이언트가 서버에서 응답을 받기 전까지 기다린다. 고로 동기형 Synchronous 이다.</p>\n<p>클라이언트와 서버에서 일어나는 구도.</p>\n<ol>\n<li>요청 메시지 구축 </li>\n<li>요청 메시지 송신 </li>\n<li>(응답이 돌아올 때까지 대기) </li>\n<li>응답 메시지 수신</li>\n<li>응답 메시지 해석</li>\n<li>클라이언트의 목적을 달성하기 위해 필요한 처리</li>\n</ol>\n<p>서버 측</p>\n<ol>\n<li>(요청을 대기)</li>\n<li>요청 메시지 수신</li>\n<li>요청 메시지 해석</li>\n<li>적절한 애플리케이션 프로그램으로 처리를 위임</li>\n<li>애플리케이션 프로그램으로 부터 결과를 취득</li>\n<li>응답 메시지 구축</li>\n<li>응답 메시지 송신</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>클라이언트</th>\n<th>서버</th>\n<th></th>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>요청 메시지 구축</td>\n<td>(요청을 대기)</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>요청 메시지 송신</td>\n<td>(요청을 대기)</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>(응답이 돌아올 때까지 대기)</td>\n<td>요청 메시지 수신</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>(응답이 돌아올 때까지 대기)</td>\n<td>요청 메시지 해석</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>(응답이 돌아올 때까지 대기)</td>\n<td>적절한 애플리케이션 프로그램으로 처리를 위임</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>(응답이 돌아올 때까지 대기)</td>\n<td>애플리케이션 프로그램으로부터 결과를 취득</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>(응답이 돌아올 때까지 대기)</td>\n<td>응답 메시지 구축</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>(응답이 돌아올 때까지 대기)</td>\n<td>응답 메시지 송신</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>응답 메시지 수신</td>\n<td>(요청을 대기)</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>응답 메시지 해석</td>\n<td>(요청을 대기)</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>클라이언트의 목적을 달성하기 위해 필요한 처리</td>\n<td>(요청을 대기)</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<p>이 되겠다.</p>\n<p>요청 메시지와 응답 메시지를 합해서 HTTP 메시지라고 부른다.</p>\n<p>요청 메시지</p>\n<div class=\"gatsby-highlight\" data-language=\"html\"><pre class=\"language-html\"><code class=\"language-html\">GET/test HTTP/1.1 \n<span class=\"token comment\">&lt;!-- requestline with GET method, /test URI, version 1.1 --></span>\nHost: example.com</code></pre></div>\n<p>요청 메시지 둘째 줄부터는 헤더 메타 데이터입니다. 헤더의 기본 구성은 ‘이름:값’ 이다. 그 후에 들어가는 건 바디 다. 바디는 그 메시지를 나타내는 본질적인 정보가 들어가 있다.</p>\n<p>응답 메시지</p>\n<div class=\"gatsby-highlight\" data-language=\"html\"><pre class=\"language-html\"><code class=\"language-html\">HTTP/1.1 200 OK\n<span class=\"token comment\">&lt;!-- 스테이터스 라인 with 1.1 protocol version, statuscode 200, text OK --></span>\ncontent-Type: application/xhtml+xml; charset=utf-8\n<span class=\"token comment\">&lt;!-- header with html MIME midea type application.xhtml+xml and utf-8 encoding --></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>html</span> <span class=\"token attr-name\">xmlns</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>http://www.w3.org/1999/xhtml<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n....\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>html</span><span class=\"token punctuation\">></span></span></code></pre></div>\n<p>status code는 요청 결과를 프로그램으로 처리 가능한 수치로 표현한 것 이다.<br>\n응답 두 번째 줄부터 헤더다. </p>\n<table>\n<thead>\n<tr>\n<th>HTTP 구조</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>스타트 라인</td>\n</tr>\n<tr>\n<td>헤더</td>\n</tr>\n<tr>\n<td>빈칸</td>\n</tr>\n<tr>\n<td>바디</td>\n</tr>\n</tbody>\n</table>\n<p>헤더의 끝을 빈 줄로 인식하므로 잊지 말 것. 바디는 생략할 수 있다.</p>\n<p>스테이트레스, 스테이트풀</p>\n<p>웹에서 스테이트레스는 클라이언트가 요청 한 것들을 서버가 기억을 안 한다. 스테이트풀은 반대로 요청한 것을 다 기억하는 기능이다. 스테이트풀로 할 경우에는 주고받는 게 간결 해질 수도 있지만 접속하는 클라이언트가 많으면 그만큼 서버가 필요하고 그 서버 간에 동기화도 필요해서 확장이 힘들다. 스테이트레스는 저장하는 게 없음으로 확장성이 뛰어나다. 결국엔 심플함으로 만들어서 이제까지 잘 쓰이고 있다.</p>\n<h1 id=\"ch7-http-메서드\" style=\"position:relative;\"><a href=\"#ch7-http-%EB%A9%94%EC%84%9C%EB%93%9C\" aria-label=\"ch7 http 메서드 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>ch7 HTTP 메서드</h1>\n<p>HTTP 메서드로 서버에게 클라이언트가 하고 싶은 처리를 전달한다.</p>\n<table>\n<thead>\n<tr>\n<th>메서드</th>\n<th>의미</th>\n<th>성질(crud)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>get</td>\n<td>리소스 취득</td>\n<td>read</td>\n</tr>\n<tr>\n<td>post</td>\n<td>서브 리소스 작성, 데이터 추가 등</td>\n<td>create</td>\n</tr>\n<tr>\n<td>put</td>\n<td>리소스 갱신, 리소스 작성 (전체 수정)</td>\n<td>create/update</td>\n</tr>\n<tr>\n<td>delete</td>\n<td>리소스 삭제</td>\n<td>delete</td>\n</tr>\n<tr>\n<td>head</td>\n<td>리소스의 헤더 취득</td>\n<td></td>\n</tr>\n<tr>\n<td>options</td>\n<td>리소스가 서포트하는 메서드 취득</td>\n<td></td>\n</tr>\n<tr>\n<td>trace</td>\n<td>자기 앞으로 요청 메시지를 반환 시험</td>\n<td></td>\n</tr>\n<tr>\n<td>connect</td>\n<td>프록시 동작의 터널 접속으로 변경</td>\n<td></td>\n</tr>\n<tr>\n<td>patch</td>\n<td>부분 수정</td>\n<td>update</td>\n</tr>\n</tbody>\n</table>\n<p>HTTP 메서드 중에 CRUD(Create Read Update Delete) 성질을 띠는 것들을 많이 사용한다.</p>\n<p>이러한 메서드들 덕분에 URI가 Uniform Interface 유지가 가능했다.</p>\n<p>헤더에 조건부 요청을 넣어서 실행 여부를 구성 할 수 있다. 예를 들어서 if-modified-since 을 하면 헤더가 작성했을 때부터 현재까지 수정 부분 있으면 실행하는 것이다.</p>\n<p>멱등성과 안전성\n이러한 메서드들을 멱등성과 안전성으로 구분해서 쓰기도 한다. 멱등성(idempotence)이란 입력이 같을때 출력이 같은 것이다. 안전성(safe)은 리소스에 변화를 주지 않는 것이다.</p>\n<table>\n<thead>\n<tr>\n<th>메서드</th>\n<th>성질</th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>get, head</td>\n<td>멱등이고 안전하다</td>\n<td></td>\n</tr>\n<tr>\n<td>put, delete</td>\n<td>멱등이지만 안전하지 않다</td>\n<td></td>\n</tr>\n<tr>\n<td>post, patch</td>\n<td>멱등도 아니고 안전하지도 않다</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<p>이러한 메서드들로 rest의 통일된 인터페이스를 구축하고 심플한 프로토콜을 유지한다.</p>\n<h1 id=\"ch8-스테이터스-코드\" style=\"position:relative;\"><a href=\"#ch8-%EC%8A%A4%ED%85%8C%EC%9D%B4%ED%84%B0%EC%8A%A4-%EC%BD%94%EB%93%9C\" aria-label=\"ch8 스테이터스 코드 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>ch8 스테이터스 코드</h1>\n<p>위에서 말했듯이 status code는 요청 결과를 프로그램으로 처리 가능한 수치로 표현한 것 이다. 스테이터스 코드의 종류들은 이러하다.</p>\n<blockquote>\n<p>1xx : 처리 중<br>\n2xx : 성공<br>\n3xx : 리다이렉트<br>\n4xx : 클라이언트 에러<br>\n5xx : 서버 에러  </p>\n</blockquote>\n<p>이러한 숫자를 받음으로써 클라이언트가 어떻게 처리해야 할지 알게 된다.</p>\n<p>자주 쓰는 스테이터스 코드</p>\n<p>200 OK </p>\n<table>\n<thead>\n<tr>\n<th>스테이터스 코드</th>\n<th>의미</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>200 OK</td>\n<td>요청 성공</td>\n</tr>\n<tr>\n<td>201 Created</td>\n<td>리소스 작성 성공</td>\n</tr>\n<tr>\n<td>301 Moved Permanently</td>\n<td>리소스 항구적인 이동</td>\n</tr>\n<tr>\n<td>303 See Other</td>\n<td>리다이렉트</td>\n</tr>\n<tr>\n<td>400 Bad Request</td>\n<td>요청 구문이나 파라미터 에러</td>\n</tr>\n<tr>\n<td>401 Unauthorized</td>\n<td>접근 권한 없음, 인증 실패</td>\n</tr>\n<tr>\n<td>404 Not Found</td>\n<td>리소스 없음</td>\n</tr>\n<tr>\n<td>500 Internal Server Error</td>\n<td>서버 에러</td>\n</tr>\n<tr>\n<td>503 Services Unavailabe</td>\n<td>서비스 중지</td>\n</tr>\n</tbody>\n</table>\n<p>스테이터스 코드들을 올바르게 역할별로 사용해야 한다. 이것은 아주 중요한 설계 검토 사항이다. </p>\n<p>참고로 스테이터스 코드의 구체적인 구현방법은 웹서비스와 프레임워크에 따라 달라진다.</p>\n<h1 id=\"ch-9-http-헤더\" style=\"position:relative;\"><a href=\"#ch-9-http-%ED%97%A4%EB%8D%94\" aria-label=\"ch 9 http 헤더 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>ch 9 HTTP 헤더</h1>\n<p>헤더는 메시지의 바디에 대한 부가적인 정보, 즉 메타 데이터를 표현한다. 클라이언트와 서버는 헤더를 보고 메시지에 대한 동작을 결정한다. 예를 들어서 캐시나 인증 등은 헤더를 써야지만 구현이 가능하다.  </p>\n<p>헤더의 종류.\n날짜 시간,\ncontent type,\ncharset 파라미터,\n언어,\n콘텐트 네고시에이션,\ncontent length,\n인증,\n캐시,\n지속적 접속,\ncontent disposition 등이 있다</p>\n<p>날짜 시간은 메시지 생성한 일시, 응답을 캐시 할 수 있는 기한 등을 가지고 있다.<br>\ncontent type 는 미디어 타입(MIME)을 결정한다.  </p>\n<div class=\"gatsby-highlight\" data-language=\"html\"><pre class=\"language-html\"><code class=\"language-html\">Content-Type:application/xhtml+xml; charset=utf-8\n              <span class=\"token comment\">&lt;!-- type/subtype --></span></code></pre></div>\n<p>charset 은 문자 인코딩 방식을 지정한다.<br>\n언어는 자연언어를 지정하는 헤더다.</p>\n<div class=\"gatsby-highlight\" data-language=\"html\"><pre class=\"language-html\"><code class=\"language-html\">Content-Language: ko-KR</code></pre></div>\n<p>콘텐트 네고시에이션은 언어의 우선순위를 지정한다</p>\n<div class=\"gatsby-highlight\" data-language=\"html\"><pre class=\"language-html\"><code class=\"language-html\">Accept-Language: ko; q=1.0, en; q=0.5\n<span class=\"token comment\">&lt;!-- 한국어 1순위 영어 2순위 --></span></code></pre></div>\n<p>content length 바디의 길이를 지정한다. 이것을 분할(chunk)로 보낼 수도 있다<br>\n인증은 말 그대로 인증하기 위한 키들의 헤더이다. 인증 방식은 많다. basic, digest, https, OAuth 등. 요즘은 OAuth(Open Authentication) 2.0 을 쓴다. 이것은 제3자 앱에 제공 없이 인증 할 수 있는 프로토콜이다.<br>\n캐시 - 는 서버로부터 가져온 리소스를 로컬 스토리지에 저장하여 재사용하는 방법이다.<br>\n헤더에 cache를 지정할 때 Pragma나 Expires나 두 기능 다 있는 Cache-Control 쓰면 된다. Pragma 는 no-cache 만 쓸 수 있고 Expires는 말 그대로 유효기한 설정해준다. Cache-Control은 둘 다 할 수 있다. 또한 조건부 get인 if-modified로 유효기한 갱신 그리고 eTag로 갱신 상태 비교 등을 써서 유효기한을 변경할 수 있다.<br>\n지속적 접속 - http 1.1 에서부턴 지속 접속 기능이 있는 pipeline 화 돼 있어서 커넥션을 끊고 싶을 때 Connection:close 헤더를 쓰면 된다.<br>\ncontent disposition- 리소스 파일명을 제공해주는 헤더이다.  </p>\n<p>이러한 헤더들을 이용해서 HTTP의 주요 기능들을 구현할 수 있다.</p>\n<h1 id=\"ch-10\" style=\"position:relative;\"><a href=\"#ch-10\" aria-label=\"ch 10 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>ch 10</h1>\n<p>HTML(Hypertext Markup Language)란 태그로 문서의 구조를 표현하는 컴퓨터 언어다. 이러한 구조를 가지는 문서를 구조화 문서라고 한다.</p>\n<p>HTML 미디어 타입은 application/xhtml+xml 이다.<br>\nxml은 요소로 문서의 구조를 나타낸다. start tag, content, endtag. 이 요소들은 중첩하여 표현한다. 또한 빈 요소로도 쓸 수 있다. 이 요소들은 속성을 여러 개가질 수 있다. 어떤 문자들은 명령어로 지정되어 있어서 Unicode 로 지정해서 문자들을 작성해야 한다. 이것을 escaping이라고도 한다.<br>\n복수의 XML 포맷을 조합할 때 이름의 충돌을 방지할 목적으로 Namespace를 쓴다. 예를들어서 </p>\n<div class=\"gatsby-highlight\" data-language=\"html\"><pre class=\"language-html\"><code class=\"language-html\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>link</span> <span class=\"token attr-name\">rel</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span> <span class=\"token punctuation\">\"</span>stylesheet<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token namespace\">qwe:</span>link</span> <span class=\"token attr-name\">rel</span> <span class=\"token attr-value\"><span class=\"token punctuation\">=</span> <span class=\"token punctuation\">\"</span>enclosure<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span></code></pre></div>"}