{"componentChunkName":"component---src-templates-post-template-js","path":"/study/2020-02-23-HTTP-Network-Basic/","result":{"data":{"markdownRemark":{"id":"8bf260e6-609f-5871-8c88-f165f9c1569f","html":"<ol>\n<li>WWW을 구성하는 3가지 핵심 요소를 나열하고 각각에 대하여 설명하시오. (16p) </li>\n</ol>\n<p>HTML(HyperText Markup Language): 문서 기술 언어<br>\nHTTP(HyperText Tranfer Protocol): 문서 전송 프로토콜<br>\nURL(Uniform Resource Locator): 문서 주소 지정 방법  </p>\n<ol start=\"2\">\n<li><a href=\"http://user:pass@www.example.jp:80/dir/index.htm?uid=1#ch1\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">http://user:pass@www.example.jp:80/dir/index.htm?uid=1#ch1</a> 과 같은 절대 URI를 구성하는 7가지 구성 요소를 밑줄로 구분해서 설명하시오. (33p)  </li>\n</ol>\n<p>스키마 http://<br>\n자격정보 user:pass@<br>\n서버 주소www.example.jp:<br>\n서버 포트 80/<br>\n계층적 파일 패스 dir/index.htm<br>\n쿼리 문자열 ?uid=1<br>\n프래그먼트 식별자 #ch1</p>\n<ol start=\"3\">\n<li>아래 리퀘스트 메시지에서 구성 요소 5가지를 구분하시오. (40p)<br>\nPOST /form/entry HTTP/1.1\nHost: hackr.jp\nConnection: keep-alive\nContent-Type: application/x-www-form-urlencoded\nContent-Length: 16\nname=ueno&#x26;age=37  </li>\n</ol>\n<p>POST 메소드<br>\n/form/entry  URI\nHTTP/1.1 프로토콜 버전<br>\nHost … 16 리퀘스트 헤더 필드<br>\nname=ueno&#x26;age=37 엔티티</p>\n<ol start=\"4\">\n<li>\n<p>아래 리스폰스 메시지에서 구성 요소 5가지를 구분하시오. (42p)<br>\nHTTP/1.1 200 OK\nDate: Tue, 10 Jul 2012 06:50:15 GMT\nContent-Length: 362\nContent-Type: text/html</p>\n<html>\n...\n</li>\n</ol>\n<p>HTTP/1.1 프로토콜 버전 200 상태 코드 OK 상태 코드 설명\nDate: Tue, 10 Jul 2012 06:50:15 GMT\nContent-Length: 362\nContent-Type: text/html\n리스폰스 헤더 필드</p>\n<html>\n...\n바디\n<ol start=\"5\">\n<li>HTTP 지속 연결(keep alive)의 등장 배경과 장점에 대해서 설명하시오. (54~56p)<br>\n리퀘스트 보낼 때마다 매번 tcp 연결과 종료를 하게 되는 쓸모 없는 일이 발생되어 통신량이 늘어나게 됩니다. 이 문제를 해결하기 위해서 지속 연결이 등장하는데 연결과 종료르 반볻괴는 오버헤드를 줄여줘서 서버에 대한 부하가 경감된다. 그리고 그만큼 통신이 빠르게 완료가 된다.</li>\n<li>HTTP pipelining이 무엇인지 설명하시오. (57p)<br>\n리퀘스트를 병렬로 보낼 수 있도록 만듬</li>\n<li>HTTP는 stateless 프로토콜이다. stateless 프로토콜의 장점과 단점을 설명하시오. (58p)<br>\n과거 상태를 근거로 해서 현재 리퀘스트를 처리가 불가능하다. 그래도 상태를 유지 않는다는 점에서 서버의 CPU나 메모리 같은 리소스의 소비를 억제할 수 있다.</li>\n<li>쿠키의 등장 배경과 쿠키 발행과 클라이언트의 쿠키 사용 과정을 설명하시오. (58~59p)<br>\nSTATELESS의 문제를 해결하기 위해서 쿠키라는 시스템 도입됬다. 쿠키는 서버에서 리스폰스로 보내진 SET-COOKIE라는 해더 필드에 의해 쿠키를 클라이언트에 보존하게 된다. 다음 번에 클라이언트가 같은 서버로 리퀘스트를 보낼때, 자동으로 쿠키 값을 넣어서 송신한다. </li>\n<li>HTTP 메시지의 구성 요소 3가지를 나열하고 각각에 대하여 설명하시오. (62p)<br>\n메시지 헤더: 서버와 클라이언트가 꼭 처리해야 하는 리퀘스트와 리스폰스 내용과 속성등.<br>\nCR+LF: 개행 문자<br>\n메시지 바디 꼭 전송되는 데이터 그 자체</li>\n<li>메시지 바디와 엔티티 바디의 차이점을 설명하시오. (65p)<br>\n메시지 바디와 엔티티 바디는 같지만 전송 코딩이 적용된 경우에는 엔티티 바디의 내용이 변화히기 때문에 메시지 바디와 달라진다.</li>\n<li>Content Codings과 Chunked transfer Coding의 차이점을 설명하시오. (66~67p)<br>\n콘텐츠 코딩은 압축해서 보내고 청크 전송 코딩은 분할해서 보낸다.</li>\n<li>HTTP에서 Multipart 전송은 언제 사용하는가? 각각의 엔티티를 구분하기 위해 사용하는 문자열을 무엇이라 하는가? (68~70p)<br>\nMIME 같은 다양한 데이터를 다루기 위해서 쓰기 위해서 멀티 파트라고 하는 여러 다른 종류의 데이터를 수용하는 방법을 쓴다. 이 엔티티를 구분하기 위해 BOUNDARY 문자열을 써서 구분한다. </li>\n<li>Content Negotiation에 대하여 설명하시오. (73~74p)<br>\n웹 마다 다른 언어를 쓰는데 최적의 언어를 반환 해주는거다.</li>\n<li>상태 코드의 역할은 무엇인가? (78p)<br>\n클라이언트가 서버를 향해 리퀘스트를 보낼 때 서버에서 그 결과가 어떻게 되었는지 알려주는 것이 상태 코드의 역할이다.</li>\n<li>2xx, 3xx, 4xx, 5xx 리스폰스가 의미하는 바를 각각 설명하시오. (79~89p)<br>\n2: 리퀘스트를 정상적으로 처리했음<br>\n3: 리퀘스트를 완료하기 위해서 추가 동작이 필요<br>\n4: 서버는 리퀘스트를 이해 불가능<br>\n5: 서버는 리퀘스트 처리 실패  </li>\n<li>프록시의 2가지 종류를 나열하고 각각을 설명하시오. (96~97p)<br>\n캐싱 프록시: 캐시를 보존해 두는 타입으로 서버로부터 리소스를 획득하는 것이 아니라 캐시를 리스폰스로서 되돌려 주는 것이다.<br>\n투명 프록시: 리퀘스트와 리스폰스를 중계 할 때 메시지 변경을 하지 않는 타입.  </li>\n<li>게이트웨이를 사용하는 이유와 그 역할은 무엇인가? (97p)<br>\nHTTP 서버 이외의 서비스를 제공하는 서버이다. 클라이언트와 게이트웨이 사이를 암호화하는 등으로 안전하게 접속함으로써 통신의 안전성을 높이는 역할등을 한다.</li>\n<li>터널의 사용하는 이유와 그 역할은 무엇인가? (98p)<br>\n터널은 요구에 따라서 다른 서버와의 통신 경로를 확립한다. </li>\n<li>캐시 서버의 장점은 무엇인가? 유효기간이 있는 이유는? (99p)<br>\n캐시는 프록시 서버와 클라이언트의 로컬 디스크에 보관된 리소스의 사본이다. 이걸로 서버에의 액세스를 줄이는것이 가능하기 때문에 통신량과 통신 시간을 절약할 수 있다.</li>\n<li>4종류의 HTTP 헤더 필드를 나열하고 각각을 설명하시오. (108~109p)<br>\n일반적 헤더 필드: 리퀘스트 메시지와 리스폰스 메시지 둘 다 사용되는 헤더.<br>\n리퀘스트 헤더 필드: 클라이언트 측에서 서버 측으로 송신된 리퀘스트 메시지에 사용되는 헤더로 리퀘스트의 부가적 정보와 클라이언트의 정보, 리스폰스의 콘텐츠에 관한 우선 순위 등을 부가한다.<br>\n리스폰스 헤더 필드: 서버 측에서 클라이언트 측으로 송신한 리스폰스 메시지에 사용되는 헤더로 리스폰스의 정보와 서버의 정보, 클라이언트의 추가 정보 요구 등을 부가한다.<br>\n엔티티 헤더 필드: 리퀘스트 메시지와 리스폰스 메시지에 포함된 엔티티에 사용되는 헤더로 콘텐츠 갱신 시간 등의 엔티티에 관한 정보를 부가한다. </li>\n<li>End-to-end, Hop-by-hop 헤더의 차이점을 설명하시오. (112p)<br>\nEnd-to-end: 리퀘스트나 리스폰스의 최종 수신자에게 전송된다. 캐시에서 구축된 리스폰스 중 보존되야 하고 다시 전송되지 않으면 안되도록 되어 있다.<br>\nhop-by-hop: ㅇ헤드는 한번 전송에 대해서만 유호하고 캐시와 프록시에 의해서 전송되지 않는 것도 있다.</li>\n<li>Cache-Control: no-cache 디렉티브가 클라이언트 리퀘스트, 서버 리스폰스에서 사용됐을 때 각각의 동작에 대해서 설명하시오. (117p)<br>\n클라이언트에서는 서버에서 가져오라는 명령을 하고 서버측에서 쓰이면 캐시 서버에 캐시가 가능하게는 하나나 매번 서버와 확인 작업을 거쳐야 한다.</li>\n<li>Connection 헤더 필드의 2가지 역할을 설명하시오. (123p)<br>\n프록시에 더이상 전송하지 않는 헤더 필드를 지정<br>\n지속적 접속 관리</li>\n<li>Upgrade 헤더 필드를 사용하는 이유와 사용할 때 추가적으로 지정해야될 필드는 무엇인가? (130p)<br>\nconnection</li>\n<li>Via 헤더 필드를 사용하는 이유는 무엇인가? 어떤 상황에 반드시 추가해줘야 하는가? (130p)<br>\n서버 간의 리퀘스트 혹은 리스폰스 메시지의 경로를 알기 위해서 사용된다. 전송된 메시지의 추적과 리퀘스트 루프의 회피등에 사용되기 때문에 프록시를 경유하는 경우에는 반드시 부가해야 된다.</li>\n<li>Accept-Language: ko-kr, en-us;q=0.7, en; q=0.3 이 의미하는 바는 무엇인가? (138p)<br>\n컨텐츠 네고시에이션 1순위 한국어 2순위 영어</li>\n<li>HTTP/1.1에서 유일한 필수 헤더 필드 이름은 무엇인가? 이 헤더 필드가 존재하는 이유는? (142p)<br>\nHost 헤더 필드. 리퀘스트한 리소스의 인터넷 호스트와 포트 번호를 전달한다. 1대의 서버에서 복수의 도메인을 할당할 수 있는가상 호스트의 구조와 관련있다. 리퀘스트가 서버에 오면 호스트 명을 ip 주소로 해결해 리퀘스트가 처리 된다. 이때 같은 ip 주소로 복수의 도메인이 적용되어 있다고 한다면 어느 도메인에 대한 리퀘스트인지 알 수가 없다.</li>\n<li>If-Match, If-None-Match, If-Modified-Since, If-Unmodified-Since, If-Range는 각각 어떤 값을 기준으로 신선도를 판단하는가? (143~149p)<br>\nIf-Match:etag<br>\nIf-None-Match:etag<br>\nIf-Modified-Since:갱신날짜<br>\nIf-Unmodified-Since:갱신날짜<br>\nIf-Range:etag, 갱신날짜</li>\n<li>ETag 헤더 필드는 어떤 상황에 쓰는가? (157~158p)\n일의적으로 리소스를 특정하기 위한 문자열을 전달한다. </li>\n<li>Location 헤더 필드에 대하여 아는 대로 설명하시오. (159~160p)<br>\n리스폰스의 수신자에 대해서 request-uri 이외의 리소스 엑세스를 유도한다.</li>\n<li>Vary 헤더 필드에 대하여 아는 대로 설명하시오. (162~163p)<br>\n캐시 컨트롤 하기 위해서 사용된다. 오리진 서버로 부터 vary에 지정되었던 리스폰스를 받아들인 프록시 서버는 이후 캐시된 때의 리퀘스트와 같은 vary에 지정되어 있는 헤더 필드를 가진 리퀘스트에 대해서만 캐시를 반환할 수 있다.</li>\n<li>Content-MD5의 작동 방식에 대해서 설명하고 그 한계점에 대해서 설명하시오. (168~169p)<br>\n메시지 바디가 변경 되지 않고 도착했는지 확인 하기 위한 md5 알고리즘을 쓰는 방식이다. 메시지 바디에 따라 content-md5도 같이 변경 할 수 있어서 한계다.</li>\n<li>Cookie에서 Expires 속성을 생략한 경우 Cookie의 유효기간은? 그리고 Cookie를 삭제하는 방법은? (174p)<br>\n브라우저를 닫는 순간까지. 쿠키를 덮어 쓰거나 클라이언트 측에서 삭제 하는것이 가능하다. </li>\n<li>Cookie에서 Domain 속성을 지정하지 않은 경우 Cookie 적용 대상은? example.com으로 Domain을 지정했을 때 송출 가능한 도메인을 2개 이상 쓰시오. (175p)<br>\ncookie를 생성한 domain 전체.</li>\n<li>Cookie에서 secure 속성은 어떤 이유로 존재하는가? (175p)<br>\n웹페이지가 HTTPS에서 열렸을 때에만 쿠키 송출을 제한하기 위해서 지정한다.</li>\n<li>HttpOnly 속성이 부여된 Cookie는 JavaScript의 A에서 읽어들일 수 없게 된다. B에서 JavaScript를 이용해 Cookie를 훔치지 못하게 한다. 위 문장에서 A와 B에 들어갈 단어는 무엇인가? (176p)<br>\ndocument.cookie, XSS</li>\n<li>도청 가능성을 방지하기 위한 통신 암호화, 콘텐츠 암호화 각각에 대해서 설명하시오. (187~188p)<br>\n통신 암호화: SSL이나 TLS이라는 다른 프로토콜을 조합함으로써 HTTP의 통신 내용을 암호화 할 수 있다. SSL등을 이용해 안전한 통신로를 확립하고 통신한다.<br>\n콘텐츠 암호화: 콘텐츠의 내용 자체를 암호화해 버리는 방법이다. 즉 메시지를 암호화 해서 보내는것이다. </li>\n<li>위장 가능성을 방지하기 위한 방법에 대하여 설명하시오. (190p)<br>\n상대를 확인 하기 위한 증명서를 발급을 하고 그것으로 확인하는것.</li>\n<li>변조 가능성을 방지하기 위한 방법과 그 한계점에 대하여 설명하시오. (192~193p)<br>\nmd5나 sha-1등 해시값을 확인하는 방법과 파일의 디지털 서명을 확인 하는 방법. md5나 sha-1의 해시값도 변조가 가능해서 한계이고, 서명 또한 변조가 가능하다.</li>\n<li>HTTPS의 프로토콜 계층 구조를 그려보시오. (195p)<br>\n애플리케이션, SSL, TCP, IP</li>\n<li>공통키 암호의 딜레마는 무엇인가? 그리고 이를 해결한 공개키 암호화 방식에 대하여 설명하시오. (196~197p)<br>\n공통키는 키를 넘기기 위해서 네트워크를 사용하는데 이때 탈취가 가능하다. 그리고 받은 키를 안전하게 보관해야 한다.<br>\n공개키는 비밀키로 부터 만들어서 그것을 보내서 공개키로 만든 메시지를 받는다. 그 메시지는 비밀키로만 풀 수 있다.</li>\n<li>HTTPS에서 공개키 암호의 느린 처리 속도를 극복하기 위해 어떤 방식을 채택하고 있는가? (198~199p)<br>\n공개키를 보낼때 공개키 암호 방식으로 보내고 그 후로 메시지를 보낼때는 공통키로 보낸다.  </li>\n<li>공개키 인증서가 필요한 이유는 무엇인가? (199p)<br>\n공개키가 진짜인지 아닌지를 증명할 수 없어서 필요하다.</li>\n<li>인증기관의 비밀키와 공개키를 이용하여 서버 클라이언트가 메시지를 송수신하는 과정을 설명하시오. (200~201p)  </li>\n<li>서버의 공개키를 인증 기관에 등록한다</li>\n<li>인증 기관의 비밀키로 서버의 공개키에 디지털 서명으로 공개키 증명서를 작성 등록</li>\n<li>서버의 공개키 증명서를 입수하고, 디지털 서명을 인증 기관의 공개 키로 검증하고, 공개키가 진짜인지 확인한다.</li>\n<li>서버의 공개키로 암호화 해서 메시지를 송신 기관에 등록</li>\n<li>서버의 비밀키로 메시지를 복호화 한다.</li>\n<li>클라이언트 증명서에 대해 설명하고 문제점에 대해서 모두 설명하시오. (202p)\n상대가 의도한 클라이언트인 것을 증명하기 위한것이다.<br>\n문제는 증명서의 입수와 배포에 있다. 증명서는 유료로 구입해야 해서 만드는 만큼 비용이 들고 클라이언트의 실재를 증명할 뿐, 사용자의 존재 유무를 증명하는 증명서가 아니다.</li>\n<li>HTTPS의 통신 과정을 모두 설명하시오. (206~208p)<br>\n클라이언트 &#x3C;-handshake-> 서버<br>\nclienthello-> 로 ssl 통신 시작<br>\n&#x3C;- server hello 로 암호 스위트 및 ssl 버전등으로 응답.<br>\n&#x3C;- certificate 메시지 전송<br>\n&#x3C;- serverhellodone 메시지 끝 알림.<br>\n-> clientkey exchange로 PRE-MASTER SECRET 등 포함됨.<br>\n-> CHANGE CIPHER SPEC<br>\n-> CLIENT FINISHED 끝 알림.<br>\n&#x3C;- CHANGE CIPHER SPEC<br>\n&#x3C;- FINISHED<br>\n-> APPLICATION DATA  애플리케이션 계층의 프로토콜에 의해 통신 시작\n&#x3C;- APPLICATION DATA 위와 동일\n-> 접속 종료</li>\n<li>SSL 통신이 지연되는 이유 2가지에 대해 모두 설명하시오. (209p)\n통신 속도가 떨어진는데 TCP 접속과 HTTP의 리퀘스트/리스폰스 이외에 SSL에 필요한 통신이 추가 되서 처리해야 할 통신이 증가해서 그렇다.<br>\nCPU나 메모리 등의 리소스를 다량으로 소비해서 처리 속도가 느려진다. 암호화나 복호하를 위한 계산을 할 필요가 있기 때문이다.</li>\n<li>BASIC 인증 수순에 대하여 모두 설명하시오. (216~217p)<br>\n리퀘스트 송신<br>\n서버에서 상태 코드 401로 응답해서 인증이 필요하다는 것을 전달한다.<br>\n클라이언트는 유저ID와 패스워드를 BASE64 형식으로 인코드한 것을 송신한다.<br>\n서버에서 인증 성공 시에는 상태 코드 200으로 응답하고, 실패했을 경우에는 다시 상태 코드 401로 응답한다.</li>\n<li>세션 관리와 쿠키에 의한 폼 베이스 인증 과정을 모두 설명하시오. (225~227p)<br>\n클라이언트가 서버 상의 웹 애플리케이션에 자격 정보를 송신하여 그 자격 정보의 검증 결과에 따라 인증하는 방식이다. 세션 관리를 위해서 쿠키를 사용하는 방법이 있다. 인증 자체는 서ㅂ 측의 웹 애플리케이션 등에 으해서 클라이언트가 송신해온 유저 ID 와 패스워드가 사전에 등록하고 있는것 과 일치하는지 어떤지를 검증하면서 이루어 진다.<br>\n클라이언트에서 자격 정보를 서버에 보낸다. 서버에서 유제에게 세션 ID를 발행하고 인증 상태를 기록. 세션 ID를 쿠키로 송신한다. 클라는 쿠키로 세션ID를 매번 송신한다. 서버는 세션 ID를 검증함으로써 앞선 유저라고 판단한다. </li>\n<li>HTTP에서 병목 현상의 원인이 되는 사양들을 모두 쓰시오. (231p)<br>\n1개의 커넥션으로 1개의 리퀘스트만 보낼 수 있다.<br>\n리퀘스트는 클라이언트에서만 시작할 수 있다. 리스폰스만 받는 것은 불가능하다.<br>\n리퀘스트/리스폰스 헤더를 압축하지 않은 체로 보낸다. 헤더의 정보가 많을수록 지연이 심해진다.<br>\n장황한 헤덜르 보낸다. 매번 같은 헤더를 보낸느것은 낭비다.<br>\n데이터 압축을 임의로 선택할 수 있다. 압축해서 보내는것이 강제적이지는 않다.</li>\n<li>WebSocket의 주요 특징과 커넥션 확립 과정을 모두 설명하시오. (238~240p)<br>\n서버푸시 기능: 서버는 클라이언트의 리퀘스트를 기다리지 않고 데이털르 보낼 수 있다.<br>\n통시량의 삭감: 핸드 쉐이크 절차를 밟을 필ㅇ가 없이 접속을 한번 확립하면 접속을 유지한다.<br>\n핸드드쉐이크/리퀘스트: 업그레이드 헤더 필드를 사용해서 프로토콜을 변경하는 것으로 핸드 쉐이크를 실시한다. 커넥션을 여러개 구분 할 수있다.<br>\n핸드쉐이크/리스폰스: 리스폰스 상태를 101SWITCHING PROTOCOL로 반환한다. 커넥션이 확립된 후에는 HTTP 가 아닌 웹소켓 독자적인 데이터 프래임을 이용해서 통신한다.<br>\n웹소켓 API: 양방향 통신을 하기 위해서 인터페이스를 사용한다.<br>\n클라이언트 &#x3C;—> 서버\n-> 헨드 쉐이크 리퀘스트\n&#x3C;- 핸드 쉐이크 리스폰스\n------ 프로토콜 변경 웹소켓으로----\n-> 데이터 전송<br>\n&#x3C;- 데이터 전송\n&#x3C;- 데이터 전송</li>\n<li>왜 HTTP는 이렇게까지 사용되고 있는가? (247~248p)<br>\n방화벽 설정으로 새로운 포트 번호를 사용하는 경우에는 설정을 변결 해야한다. HTTP로 기반된게 너무 많아서 많이 사용된다. </li>\n<li>HTML이란 무엇인가? (250p)<br>\nHTML(HYPER TEXT MARKUP LANGUAGE): 웹상에서 하이퍼 텍스트를 보내기 위해서 개발된 언어.<br>\nHYPERTEXT: 문서 시스텝의 하나로서, 문서 중에 임의의 장소의 정보가 다른 정보에 관련 즉 링크되어 있는 문서<br>\nMARKUP LANGUAGE: 문서의 일부에 특별한 문자열을 붙임으로써, 문서를 수식하는 언어이다. 이 태그를 HTML 태그라고 한다.</li>\n<li>CSS란 무엇이며 바탕이 되는 이념은 무엇인가? (252p)<br>\n문서의 구조와 디자인을 분리한다는 이념에서 만들어 졌다.</li>\n<li>DOM이란 무엇이며 왜 쓰는가? (253p)\nHTML 문서와 XML 문서를 위한 API. DOM을 사용하면 HTML내의 요소를 오브젝트로 다룰 수 있기 때문에 요소 내의 문자열을 추출하거나 CSS를 프로퍼티로서 변경해서 디자인을 변경할 수 있다. DOM을 사용하게 되면 JAVASCRIPT등의 스크립트를 사용하여 HTML을 쉽게 조작할 수 있다.</li>\n<li>웹 애플리케이션에 대하서 설명하시오. 웹 애플리케이션에 의해서 생성된 콘텐츠를 무엇이라 하는가? (254~255p)<br>\n웹기능을 사용해서 제공되는 프로그램을 지칭한다. 이러한 프로그램에 의해서 생성된 콘텐츠를 동적 콘텐츠라고 부른다. </li>\n<li>CGI란 무엇인가? 그리고 그 단점과 이를 극복하기 위한 방향에 대해 설명하시오. (255~257p)<br>\nCOMMON GATEWAY INTERFACE 는 웹 서버가 클라이언트에서 받은 리퀘스트를 프로그램에 전달하기 위한 구조이다. 이것은 리퀘스트 마다 프로그램을 기동하기 때문에 대량으로 액세스가 있을 때 웹 서버에 부하가 걸리게 되서 서블렛을 쓴다. 서블릿은 서버상에 HTML 등의 동적 콘텐츠를 생성하기 위한 프로그램인데, 웹 서버와 같은 프로세스 속에서 동작하기 때문에 비교적 부하를 적게 하여 동작 시킬수 있다.</li>\n<li>XML을 사용하는 이유를 HTML의 단점과 함께 설명하시오. (257~259p)<br>\n목적에 맞게 확장 가능한 범용적으로 사용할 수 있는 마크업 언어이다. 이것을 써서 인터넷 통해 데이터 공유를 용이하게 하는 것이 목적이다. HTML에 비해서 데이터를 기술하는 것에 특화 되어 있다. XML은 HTML과 같이 태그를 사용한 트리 구조로 되어 있고 독자적으로 확장된 태그가 정의되어 있다. XML의 데이터를 뺴내는것은 HTML에 비해 간단하다. 기본적으로 트리 구조로 되어 있기 때문에 구조를 해석하고 요소를 뽑아내는 파서 기능에 의해서 데이터 추출을 쉽게 할 수 있다. 데이터를 재사용하기 쉽다는 점에서 XML은 인터넷에서 널리 이용되고 데이터 교환 포맷으로서 서로 다른 애플리케이션 사이에서 이용되기도 한다.</li>\n<li>RSS/Atom이란 무엇인가? (259p)<br>\n뉴스나 블로그의 기사 등의 갱신 정보를 송신하기 위한 문서의 포맷의 총칭으로 둘다 XML을 이용하고 있다.</li>\n<li>JSON이란 무엇인가? (262p)<br>\n경량 데이터를 기술 언어로서 JavaScript에 있어서 오브젝트 표기법을 바탕으로 하고 있다. JSON(JavaScript Object Notation) 데이터는 단순하고 가볍게, 게다가 문자열을 JavaScript에서 간단하게 읽어올 수 있다는 장점이 있다.</li>\n</ol>","fields":{"slug":"/study/2020-02-23-HTTP-Network-Basic/","tagSlugs":null},"frontmatter":{"date":"2020-02-14","description":"그림으로 배우는 HTTP Network Basic","tags":null,"title":"그림으로 배우는 HTTP Network Basic","socialImage":null}}},"pageContext":{"slug":"/study/2020-02-23-HTTP-Network-Basic/"}}}